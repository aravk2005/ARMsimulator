import struct

ARM_INSTRUCTION_SIZE = 4  #ARM instructions are 4 bytes = 32 bits 
THUMB_INSTRUCTION_SIZE = 2 #Thumb instructions are 2 bytes = 16 bits 

def read_binary_file(filename): 
    #filename = "test_mixed_fixed.bin"   # <- test_mixed_fixed.bin was generated by generate_bin.py
    with open(filename, 'rb') as f:
        return f.read()

def decode_arm_instruction(instr):
    # Branch (B/BL)
    if ((instr >> 25) & 0b111) == 0b101:
        link = (instr >> 24) & 1
        imm24 = instr & 0xFFFFFF
        if imm24 & 0x800000:
            imm24 |= ~0xFFFFFF  # sign extend
        offset = imm24 << 2
        op = "BL" if link else "B"
        return {"op": op, "offset": offset}

    # BX
    if (instr & 0x0FFFFFF0) == 0x012FFF10:
        rm = instr & 0xF
        return {"op": "BX", "rm": rm}

    # LDR/STR (immediate offset only)
    if ((instr >> 26) & 0b11) == 0b01:
        #funct set defined below 
        p = (instr >> 24) & 1
        u = (instr >> 23) & 1    
        l = (instr >> 20) & 1
        rn = (instr >> 16) & 0xF
        rd = (instr >> 12) & 0xF
        offset = instr & 0xFFF
        op = "LDR" if l == 1 else "STR"
        sign = 1 if u else -1
        return {"op": op, "rd": rd, "rn": rn, "imm": sign * offset}

    # Data Processing 
    opcode = (instr >> 21) & 0xF
    rn = (instr >> 16) & 0xF
    rd = (instr >> 12) & 0xF
    operand2 = instr & 0xFFF

    opcode_map = {
        0b0000: 'AND',
        0b0001: 'EOR',
        0b0010: 'SUB',
        0b0100: 'ADD',
        0b1010: 'CMP',
        0b1100: 'ORR',
        0b1101: 'MOV',
    }

    op = opcode_map.get(opcode)
    if not op:
        return {"op": "UNKNOWN"}

    if op == "CMP":
        return {"op": op, "rn": rn, "imm": operand2}
    elif op == "MOV":
        return {"op": op, "rd": rd, "imm": operand2}
    else:
        return {"op": op, "rd": rd, "rn": rn, "imm": operand2}


def decode_thumb_instruction(instr):
    opcode5 = (instr >> 11) & 0x1F
    opcode7 = (instr >> 9) & 0x7F
    opcode9 = (instr >> 9) & 0x7F
    opcode10 = (instr >> 6) & 0x3FF
    opcode16 = instr >> 8

    # MOVS Rd, #imm8
    if opcode5 == 0b00100:
        rd = (instr >> 8) & 0x7
        imm8 = instr & 0xFF
        return {"op": "MOVS", "rd": rd, "imm": imm8, "size": 2}

    # ADDS Rd, Rs, #imm3 (immediate)
    elif opcode7 == 0b0001110:
        imm3 = (instr >> 6) & 0x7
        rs = (instr >> 3) & 0x7
        rd = instr & 0x7
        return {"op": "ADDS", "rd": rd, "rn": rs, "imm": imm3, "size": 2}

    # SUBS Rd, Rs, #imm3 (immediate)
    elif opcode7 == 0b0001111:
        imm3 = (instr >> 6) & 0x7
        rs = (instr >> 3) & 0x7
        rd = instr & 0x7
        return {"op": "SUBS", "rd": rd, "rn": rs, "imm": imm3, "size": 2}

    # ADDS Rd, Rn, Rm (register)
    elif (instr >> 9) == 0b0001100:
        rm = (instr >> 6) & 0x7
        rn = (instr >> 3) & 0x7
        rd = instr & 0x7
        return {"op": "ADDS", "rd": rd, "rn": rn, "rm": rm, "size": 2}

    # SUBS Rd, Rn, Rm (register)
    elif (instr >> 9) == 0b0001101:
        rm = (instr >> 6) & 0x7
        rn = (instr >> 3) & 0x7
        rd = instr & 0x7
        return {"op": "SUBS", "rd": rd, "rn": rn, "rm": rm, "size": 2}

    # MOV Rd, Rs (register-to-register, including high registers)
    elif (instr >> 6) == 0b01000110:
        rm = (instr >> 3) & 0xF
        rd = ((instr & 0x7) | ((instr >> 4) & 0x8))  # Combine D bit
        return {"op": "MOV", "rd": rd, "rs": rm, "size": 2}

    return {"op": "UNKNOWN_THUMB", "size": 2}


def is_valid_arm_opcode(instr):
    cond = (instr >> 28) & 0xF
    return 0 <= cond <= 0xF

def get_instruction_list(filename): 
    data = read_binary_file(filename)
    i = 0
    thumb_mode = False
    instruction = []

    while i < len(data):
        if not thumb_mode and i + 4 <= len(data):
            instr = struct.unpack('<I', data[i:i+4])[0]
            if is_valid_arm_opcode(instr):
                decoded = decode_arm_instruction(instr)
                decoded["size"] = 4
                instruction.append(decoded)
                i += 4
                if decoded["op"] == "BX":
                    thumb_mode = True
                continue

        if i + 2 <= len(data):
            instr = struct.unpack('<H', data[i:i+2])[0]
            decoded = decode_thumb_instruction(instr)
            decoded["size"] = 2
            instruction.append(decoded)
            i += 2
        else:
            break

    return instruction






